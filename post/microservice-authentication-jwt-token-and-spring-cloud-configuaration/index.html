<!DOCTYPE html>
<html
  lang="en"
  itemscope
  itemtype="http://schema.org/WebPage"
>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>
          Hướng dẫn sử dụng Microservice, Eureka và Zuul Gateway - Phần 2 - Cuong Vu
        </title>
    

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="Cuong Vu" />
  <meta name="description" content="Ở bài trước chúng ta đã dựng được một hệ thống microservice đơn giản với User service, Eureka server và Zuul gateway. Trong bài viết này chúng ta sẽ cùng tìm hiểu về JWT và cách để xác thực và bảo mật trong hệ thống Microservice bằng JWT.
" />

  <meta name="keywords" content="Hugo, theme, jane" />






<meta name="generator" content="Hugo 0.117.0" />


<link rel="canonical" href="https://cuongvndev.github.io/post/microservice-authentication-jwt-token-and-spring-cloud-configuaration/" />





<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.d8d87b982993a745e5e7b6a6cbf257be8c3e82aab5e485f0908ad7e6c3501ab2.css" integrity="sha256-2Nh7mCmTp0Xl57amy/JXvow&#43;gqq15IXwkIrX5sNQGrI=" media="screen" crossorigin="anonymous">







<meta property="og:title" content="Hướng dẫn sử dụng Microservice, Eureka và Zuul Gateway - Phần 2" />
<meta property="og:description" content="Ở bài trước chúng ta đã dựng được một hệ thống microservice đơn giản với User service, Eureka server và Zuul gateway.
Trong bài viết này chúng ta sẽ cùng tìm hiểu về JWT và cách để xác thực và bảo mật trong hệ thống Microservice bằng JWT." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cuongvndev.github.io/post/microservice-authentication-jwt-token-and-spring-cloud-configuaration/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2023-08-11T09:25:25+07:00" />
<meta property="article:modified_time" content="2023-08-11T09:25:25+07:00" />
<meta itemprop="name" content="Hướng dẫn sử dụng Microservice, Eureka và Zuul Gateway - Phần 2">
<meta itemprop="description" content="Ở bài trước chúng ta đã dựng được một hệ thống microservice đơn giản với User service, Eureka server và Zuul gateway.
Trong bài viết này chúng ta sẽ cùng tìm hiểu về JWT và cách để xác thực và bảo mật trong hệ thống Microservice bằng JWT."><meta itemprop="datePublished" content="2023-08-11T09:25:25+07:00" />
<meta itemprop="dateModified" content="2023-08-11T09:25:25+07:00" />
<meta itemprop="wordCount" content="2345">
<meta itemprop="keywords" content="Microservice,Eureka,Zuul Gateway,Spring Boot Security,Spring Cloud Configuration,Spring Cloud Netflix," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Hướng dẫn sử dụng Microservice, Eureka và Zuul Gateway - Phần 2"/>
<meta name="twitter:description" content="Ở bài trước chúng ta đã dựng được một hệ thống microservice đơn giản với User service, Eureka server và Zuul gateway.
Trong bài viết này chúng ta sẽ cùng tìm hiểu về JWT và cách để xác thực và bảo mật trong hệ thống Microservice bằng JWT."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->


<script async src="https://www.googletagmanager.com/gtag/js?id=G-MPBTRXJEZK"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-MPBTRXJEZK', { 'anonymize_ip': false });
}
</script>



  </head>
  <body>
    <div id="back-to-top"></div>

    <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Cuong Vu</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://cuongvndev.github.io/">Home</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://cuongvndev.github.io/post/">Archives</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://cuongvndev.github.io/tags/">Tags</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://cuongvndev.github.io/categories/">Categories</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://cuongvndev.github.io/about/">About</a>
          
        
      </li>
    

    
  </ul>
</nav>


    
      






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

    

    

    


    <header id="header" class="header">
      <div class="logo-wrapper">
  <a href="/" class="logo">
    
      Cuong Vu
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://cuongvndev.github.io/">Home</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://cuongvndev.github.io/post/">Archives</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://cuongvndev.github.io/tags/">Tags</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://cuongvndev.github.io/categories/">Categories</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://cuongvndev.github.io/about/">About</a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

    </header>

    <div id="mobile-panel">
      <main id="main" class="main bg-llight wallpaper">
        <div class="content-wrapper">
    <div id="content" class="content">
      <article class="post">
        
        <header class="post-header">
          <h1 class="post-title">Hướng dẫn sử dụng Microservice, Eureka và Zuul Gateway - Phần 2</h1>
          

          <div class="post-meta">
  <div class="post-meta-author">
    by
      <a href="/about">
        <span class="post-meta-author-name">
          Cuong Vu
        </span>
      </a>
    
  </div>

  <div class="post-meta-time">
    <time datetime="2023-08-11">
      2023-08-11
    </time>
  </div>

  


  <div class="post-meta__right">
    

    


    
    


    
    
  </div>
</div>

        </header>

        
        <div class="post-content">
          <p>Ở bài trước chúng ta đã dựng được một hệ thống microservice đơn giản với User service, Eureka server và Zuul gateway.
Trong bài viết này chúng ta sẽ cùng tìm hiểu về <strong>JWT</strong> và cách để <strong>xác thực và bảo mật</strong> trong hệ thống <strong>Microservice</strong> bằng JWT.</p>
<p>Chúng ta sẽ tạo 1 service mới là <code>auth service</code> có nhiệm vụ xác minh danh tính và tạo jwt token khi user login
Còn việc xác thực token sẽ do Zuul gateway đảm nhận, khi có 1 request gửi đến thì Zuul gateway sẽ dựa vào token được cung cấp và xác thực quyền truy cập, xác thực thành công thì mới tiến hành điều hướng request tới các service bussiness khác.</p>
<h2 id="1-jwt-json-based-token">1. JWT (Json Based Token)</h2>
<p><strong>Token</strong> là 1 chuỗi string được mã hoá được tạo ra từ hệ thống của chúng ta sau khi xác thực thành công. Và được đính kèm trong các request để cung cấp quyền truy cập vào ứng dụng.</p>
<p><strong>JWT</strong> là 1 chuẩn JSON để tạo token, được bao gồm bởi 3 phần</p>
<ul>
<li>Header: chứa thuật toán hash
<code>{type: “JWT”, hash: “HS256”}</code></li>
<li>Payload: chứa các thuộc tính user name, email,&hellip; và các giá trị của nó
<code>{username: &quot;Omar&quot;, email: &quot;omar@example.com&quot;, admin: true }</code></li>
<li>Signature: là giá trị hash của <code>Header + “.” + Payload + Secret key</code></li>
</ul>
<h2 id="2-zuul-gateway">2. Zuul gateway</h2>
<p>Ở trong gateway sẽ thực hiện 2 chức năng: một xác thực token và 2 là chặn tất cả request nếu xác thực không thành công.
Trong file <code>pom.xml</code> chúng ta cần thêm spring security và JWT</p>
<pre tabindex="0"><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;
    &lt;artifactId&gt;jjwt&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><p>Để sử dụng security thì chúng ta cần tạo 1 class extend từ <code>WebSecurityConfigurerAdapter</code> và dùng anotation <code>@EnableWebSecurity</code></p>
<pre tabindex="0"><code>package com.example.zuulserver.security;

import com.example.commonservice.security.JwtConfig;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

import javax.servlet.http.HttpServletResponse;
import javax.ws.rs.HttpMethod;

@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    
    @Autowired
    private JwtConfig jwtConfig;
    
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                .csrf().disable()
                // make sure we use stateless session; session won&#39;t be used to store user&#39;s state.
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .and()
                // handle an authorized attempts
                .exceptionHandling().authenticationEntryPoint((req, rsp, e) -&gt; rsp.sendError(HttpServletResponse.SC_UNAUTHORIZED))
                .and()
                // Add a filter to validate the tokens with every request
                .addFilterAfter(new JwtTokenAuthenticationFilter(jwtConfig), UsernamePasswordAuthenticationFilter.class)
                // authorization requests config
                .authorizeRequests()
                // allow all who are accessing &#34;auth&#34; service
                .antMatchers(HttpMethod.POST, jwtConfig.getUri()).permitAll()
                // Any other request must be authenticated
                .anyRequest().authenticated();
    }
    
    @Bean
    public JwtConfig jwtConfig() {
        return new JwtConfig();
    }
}
</code></pre><blockquote>
<p>Class JwtConfig sẽ được tạo sau ở trong phần common service</p>
</blockquote>
<p>Tiếp theo chúng ta sẽ viết class filter để xác thực token được đặt tên là <code>JwtTokenAuthenticationFilter</code>, class này sẽ extend từ <code>OncePerRequestFilter</code> filter này sẽ được kích hoạt mỗi khi request được gửi tới.</p>
<pre tabindex="0"><code>package com.example.zuulserver.security;

import com.example.commonservice.security.JwtConfig;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.filter.OncePerRequestFilter;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;
import java.util.stream.Collectors;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;

public class JwtTokenAuthenticationFilter extends OncePerRequestFilter {
    
    private final JwtConfig jwtConfig;
    
    public JwtTokenAuthenticationFilter(JwtConfig jwtConfig) {
        this.jwtConfig = jwtConfig;
    }
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        // 1. get the authentication header. Tokens are supposed to be passed in the authentication header
        String header = request.getHeader(jwtConfig.getHeader());
        
        // 2. validate the header and check the prefix
        if (header == null || !header.startsWith(jwtConfig.getPrefix())) {
            filterChain.doFilter(request, response); // if not valid go to the next filter
            return;
        }
        // If there is no token provided and hence the user won&#39;t be authenticated.
        // It&#39;s Ok. Maybe the user accessing a public path or asking for a token.
        // All secured paths that needs a token are already defined and secured in config class.
        // And If user tried to access without access token, then he won&#39;t be authenticated and an exception will be thrown.
        // 3. Get the token
        String token = header.replace(jwtConfig.getPrefix(), &#34;&#34;);
        try {  // exceptions might be thrown in creating the claims if for example the token is expired
            // 4. Validate the token
            Claims claims = Jwts.parser().setSigningKey(jwtConfig.getSecret().getBytes()).parseClaimsJws(token).getBody();
            
            String userName = claims.getSubject();
            if (userName != null) {
                List&lt;String&gt; authorities = (List&lt;String&gt;) claims.get(&#34;authorities&#34;);
                
                // 5. Create auth object
                // UsernamePasswordAuthenticationToken: A built-in object, used by spring to represent the current authenticated / being authenticated user. // It needs a list of authorities, which has type of GrantedAuthority interface, where SimpleGrantedAuthority is an implementation of that interface
                UsernamePasswordAuthenticationToken auth = new UsernamePasswordAuthenticationToken(userName, null, authorities.stream().map(SimpleGrantedAuthority::new).collect(Collectors.toList()));
                // 6. Authenticate the user
                // Now, user is authenticated
                SecurityContextHolder.getContext().setAuthentication(auth);
            }
        } catch (Exception e) {
            // In case of failure. Make sure it&#39;s clear; so guarantee user won&#39;t be authenticated
            e.printStackTrace();
            SecurityContextHolder.clearContext();
        }
        // go to the next filter in the filter chain
        filterChain.doFilter(request, response);
    }
}
</code></pre><p>Và đừng quên thêm security config để sử dụng cho class JwtConfig nhé:</p>
<pre tabindex="0"><code>...
security:
  jwt:
    uri: /auth/**
    header: Authorization
    prefix: Bearer
    expiration: 86400
    secret: JwtSecretKey
</code></pre><h2 id="3-common-service">3. Common service</h2>
<p>Service này sẽ chứa những config được sử dụng chung cho nhiều service khác
Chúng ta sẽ tạo class JwtConfig để chứa các config JWT và class này sẽ được sử dụng trong Auth service và Zuul gateway</p>
<p>Cũng tương tự như việc tạo các service khác hãy tạo mới project Spring boot và config file <code>pom.xml</code> như sau:</p>
<pre tabindex="0"><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><p>Tạo class JwtConfig như sau:</p>
<pre tabindex="0"><code>package com.example.commonservice.security;

import org.springframework.beans.factory.annotation.Value;

public class JwtConfig {
    
    @Value(&#34;${security.jwt.uri}&#34;)
    private String uri;
    
    @Value(&#34;${security.jwt.header}&#34;)
    private String header;
    
    @Value(&#34;${security.jwt.prefix}&#34;)
    private String prefix;
    
    @Value(&#34;${security.jwt.expiration}&#34;)
    private int expiration;
    
    @Value(&#34;${security.jwt.secret}&#34;)
    private String secret;
    
    public String getUri() {
        return uri;
    }
    
    public void setUri(String uri) {
        this.uri = uri;
    }
    
    public String getHeader() {
        return header;
    }
    
    public void setHeader(String header) {
        this.header = header;
    }
    
    public String getPrefix() {
        return prefix;
    }
    
    public void setPrefix(String prefix) {
        this.prefix = prefix;
    }
    
    public int getExpiration() {
        return expiration;
    }
    
    public void setExpiration(int expiration) {
        this.expiration = expiration;
    }
    
    public String getSecret() {
        return secret;
    }
    
    public void setSecret(String secret) {
        this.secret = secret;
    }
}
</code></pre><p>Tiếp theo ở các service khác, chẳng hạn như ở Zuul gateway chúng ta cần khai báo dependency common service trong file <code>pom.xml</code>:</p>
<pre tabindex="0"><code>&lt;!-- common dependency--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.example&lt;/groupId&gt;
    artifactId&gt;common-service&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><blockquote>
<p>Thêm dependency common-service vào trong các service muốn sử dụng JwtConfig
Ở đây tạm thời chỉ có 1 class JwtConfig là sẽ được dùng chung, tương lai sẽ có nhiều hơn nên mình tách ra thành common luôn để sử dụng sau này</p>
</blockquote>
<p><strong>Note</strong>: <em>Các service khác sẽ dùng chung class JwtConfig, còn về các value security.jwt.uri, security.jwt.header, &hellip; sẽ được config riêng trong file <code>application.yml</code> của từng service.</em></p>
<p>Như vậy là đã xong phần security trong <strong>Zuull gateway</strong>, tiếp theo đây sẽ tạo mới <strong>Auth service</strong></p>
<h2 id="4-auth-service">4. Auth Service</h2>
<p>Trong auth service, chúng ta sẽ làm hai việc: một là xác thực định danh mà người dùng cung cấp và hai là gen ra một token trong trường hợp xác thực hợp lệ hoặc trả về một exception nếu nó không hợp lệ.
Trong file <code>pom.xml</code> chúng ta cần các dependencies sau: Web, Eureka Client, Spring Security và JWT.</p>
<pre tabindex="0"><code>    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;
            &lt;artifactId&gt;jjwt&lt;/artifactId&gt;
            &lt;version&gt;0.9.0&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--common dependency--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.example&lt;/groupId&gt;
            &lt;artifactId&gt;common-service&lt;/artifactId&gt;
            &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre><p>File <code>application.yml</code> khai báo như các service khác:</p>
<pre tabindex="0"><code>server:
  port: 8082

eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka

spring:
  application:
    name: auth-service
  cloud:
    config:
      uri: http://localhost:8888

security:
  jwt:
    uri: /auth/**
    header: Authorization
    prefix: Bearer
    expiration: 86400
    secret: JwtSecretKey
</code></pre><p>Ở trong class application cũng cần khai báo đây là Eureka client và đánh anotation <code>@EnableWebSecurity</code> cho nó:</p>
<pre tabindex="0"><code>package com.example.authservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;

@SpringBootApplication
@EnableEurekaClient
public class AuthServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(AuthServiceApplication.class, args);
    }
}
</code></pre><p>Giống như cấu hình cổng Gateway, chúng ta cần tạo một lớp extends từ <code>WebSecurityConfigurerAdapter</code>:</p>
<pre tabindex="0"><code>package com.example.authservice.security;

import com.example.commonservice.security.JwtConfig;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

import javax.servlet.http.HttpServletResponse;
import javax.ws.rs.HttpMethod;

@EnableWebSecurity
public class SecurityCredentialsConfig  extends WebSecurityConfigurerAdapter {
    
    @Autowired
    private UserDetailsService userDetailsService;
    
    @Autowired
    private JwtConfig jwtConfig;
    
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                .csrf().disable()
                // make sure we use stateless session; session won&#39;t be used to store user&#39;s state.
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .and()
                // handle an authorized attempts
                .exceptionHandling().authenticationEntryPoint((req, rsp, e) -&gt; rsp.sendError(HttpServletResponse.SC_UNAUTHORIZED))
                .and()
                // Add a filter to validate user credentials and add token in the response header
                // What&#39;s the authenticationManager()?
                // An object provided by WebSecurityConfigurerAdapter, used to authenticate the user passing user&#39;s credentials
                // The filter needs this auth manager to authenticate the user.
                .addFilter(new JwtUsernameAndPasswordAuthenticationFilter(authenticationManager(), jwtConfig))
                .authorizeRequests()
                // allow all POST requests
                .antMatchers(HttpMethod.POST, jwtConfig.getUri()).permitAll()
                .antMatchers(HttpMethod.GET, &#34;/auth/test&#34;).permitAll()
                // any other requests must be authenticated
                .anyRequest().authenticated();
    }
    
    // Spring has UserDetailsService interface, which can be overriden to provide our implementation for fetching user from database (or any other source).
    // The UserDetailsService object is used by the auth manager to load the user from database. // In addition, we need to define the password encoder also. So, auth manager can compare and verify passwords.  @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());
    }
    
    @Bean
    public BCryptPasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    @Bean
    public JwtConfig jwtConfig(){
        return new JwtConfig();
    }
}
</code></pre><p>Trong đoạn code trên, chúng ta sử dụng interface <code>UserDetailsService</code> nên chúng ta cần implement nó:</p>
<pre tabindex="0"><code>package com.example.authservice.security;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.AuthorityUtils;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;

import java.util.Arrays;
import java.util.List;

@Service
public class UserDetailsServiceImpl implements UserDetailsService {
    @Autowired
    private BCryptPasswordEncoder encoder;
    
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        
        // TODO get user by username in db currently we hardcode user for test
        // hard coding the users. All passwords must be encoded.
        final List&lt;AppUser&gt; users = Arrays.asList(
                new AppUser(1, &#34;user&#34;, encoder.encode(&#34;12345&#34;), &#34;USER&#34;),
                new AppUser(2, &#34;admin&#34;, encoder.encode(&#34;12345&#34;), &#34;ADMIN&#34;)
        );
        
        
        for(AppUser appUser: users) {
            if(appUser.getUsername().equals(username)) {
                
                // Remember that Spring needs roles to be in this format: &#34;ROLE_&#34; + userRole (i.e. &#34;ROLE_ADMIN&#34;)
                // So, we need to set it to that format, so we can verify and compare roles (i.e. hasRole(&#34;ADMIN&#34;)).
                List&lt;GrantedAuthority&gt; grantedAuthorities = AuthorityUtils
                         .commaSeparatedStringToAuthorityList(&#34;ROLE_&#34; + appUser.getRole());
                
                // The &#34;User&#34; class is provided by Spring and represents a model class for user to be returned by UserDetailsService
                // And used by auth manager to verify and check user authentication.
                return new User(appUser.getUsername(), appUser.getPassword(), grantedAuthorities);
            }
        }
        
        // If user not found. Throw this exception.
        throw new UsernameNotFoundException(&#34;Username: &#34; + username + &#34; not found&#34;);
    }
    
    // A (temporary) class represent the user saved in the database.
    private static class AppUser {
        private Integer id;
        private String username, password;
        private String role;
        
        public AppUser(Integer id, String username, String password, String role) {
            this.id = id;
            this.username = username;
            this.password = password;
            this.role = role;
        }
        
        public Integer getId() {
            return id;
        }
        
        public void setId(Integer id) {
            this.id = id;
        }
        
        public String getUsername() {
            return username;
        }
        
        public void setUsername(String username) {
            this.username = username;
        }
        
        public String getPassword() {
            return password;
        }
        
        public void setPassword(String password) {
            this.password = password;
        }
        
        public String getRole() {
            return role;
        }
        
        public void setRole(String role) {
            this.role = role;
        }
    }
}
</code></pre><p>Bước tiếp theo cũng là bước cuối cùng, chúng ta cần một filter. Ở đây chúng ta sử dụng <code>JwtUsernameAndPasswordAuthenticationFilter</code> để xác thực định danh người dùng và tạo token. Các thông tin về username hay password phải được gửi dưới dạng POST request.</p>
<pre tabindex="0"><code>package com.example.authservice.security;

import com.example.commonservice.security.JwtConfig;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.web.util.matcher.AntPathRequestMatcher;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Collections;
import java.util.Date;
import java.util.stream.Collectors;

public class JwtUsernameAndPasswordAuthenticationFilter extends UsernamePasswordAuthenticationFilter {
    // We use auth manager to validate the user credentials
    private AuthenticationManager authManager;
    
    private final JwtConfig jwtConfig;
    
    public JwtUsernameAndPasswordAuthenticationFilter(AuthenticationManager authManager, JwtConfig jwtConfig) {
        this.authManager = authManager;
        this.jwtConfig = jwtConfig;
        
        // By default, UsernamePasswordAuthenticationFilter listens to &#34;/login&#34; path.
        // In our case, we use &#34;/auth&#34;. So, we need to override the defaults.
        this.setRequiresAuthenticationRequestMatcher(new AntPathRequestMatcher(jwtConfig.getUri(), &#34;POST&#34;));
    }
    
    @Override
    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response)
            throws AuthenticationException {
        
        try {
            
            // 1. Get credentials from request
            UserCredentials creds = new ObjectMapper().readValue(request.getInputStream(), UserCredentials.class);
            
            // 2. Create auth object (contains credentials) which will be used by auth manager
            UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(
                    creds.getUsername(), creds.getPassword(), Collections.emptyList());
            
            // 3. Authentication manager authenticate the user, and use UserDetialsServiceImpl::loadUserByUsername() method to load the user.
            return authManager.authenticate(authToken);
            
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
    
    // Upon successful authentication, generate a token.
    // The &#39;auth&#39; passed to successfulAuthentication() is the current authenticated user.  @Override
    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain,
                                            Authentication auth) throws IOException, ServletException {
        
        Long now = System.currentTimeMillis();
        String token = Jwts.builder()
                .setSubject(auth.getName())
                // Convert to list of strings.
                // This is important because it affects the way we get them back in the Gateway.
                .claim(&#34;authorities&#34;, auth.getAuthorities().stream()
                        .map(GrantedAuthority::getAuthority).collect(Collectors.toList()))
                .setIssuedAt(new Date(now))
                .setExpiration(new Date(now + jwtConfig.getExpiration() * 1000))  // in milliseconds
                .signWith(SignatureAlgorithm.HS512, jwtConfig.getSecret().getBytes())
                .compact();
        
        // Add token to header
        response.addHeader(jwtConfig.getHeader(), jwtConfig.getPrefix() + token);
    }
    
    // A (temporary) class just to represent the user credentials
    private static class UserCredentials {
        private String username, password;
        
        public String getUsername() {
            return username;
        }
        
        public void setUsername(String username) {
            this.username = username;
        }
        
        public String getPassword() {
            return password;
        }
        
        public void setPassword(String password) {
            this.password = password;
        }
    }
}
</code></pre><blockquote>
<p>Trong Auth service cũng đã sử dụng đến JwtConfig việc này tránh trùng lặp code</p>
</blockquote>
<h2 id="5-testing">5. Testing</h2>
<p>Chạy lần lượt các service Eureka, Zuul, Auth và User.</p>
<p>Đầu tiên chúng ta thử truy cập vào user service thông qua đường dẫn <code>localhost:8762/user/user-info</code> mà không có token. Chúng ta sẽ nhận về một lỗi 401 như sau:</p>
<pre tabindex="0"><code>{
    &#34;timestamp&#34;: &#34;2023-08-11T09:26:08.131+0000&#34;,
    &#34;status&#34;: 401,
    &#34;error&#34;: &#34;Unauthorized&#34;,
    &#34;message&#34;: &#34;No message available&#34;,
    &#34;path&#34;: &#34;/user/user-info&#34;
}
</code></pre><p>Để nhận <strong>token</strong>, chúng ta call api authentication <code>localhost:8762/auth</code>
<img src="/blog/microservice/authen.png" alt="Scenario 1: Across columns"></p>
<p>Bây giờ gọi lại <strong>user service</strong> kèm theo một <strong>token</strong> trong header:
<img src="/blog/microservice/user-info-auth.png" alt="Scenario 1: Across columns"></p>
<p>Ngoài ta thì bạn có thể thử chạy nhiều instance của user service để test xem các request được phân tán như thế nào. Trong phần tiếp theo, chúng ta sẽ tìm hiểu các xử lý lỗi và theo dõi trong mô hình microservice.</p>
        </div>

        
        
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">Cuong Vu</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
      2023-08-11
      
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>



        
        


        <footer class="post-footer">
          <div class="post-tags">
              <a href="https://cuongvndev.github.io/tags/microservice/">Microservice</a>
                <a href="https://cuongvndev.github.io/tags/eureka/">Eureka</a>
                <a href="https://cuongvndev.github.io/tags/zuul-gateway/">Zuul Gateway</a>
                <a href="https://cuongvndev.github.io/tags/spring-boot-security/">Spring Boot Security</a>
                <a href="https://cuongvndev.github.io/tags/spring-cloud-configuration/">Spring Cloud Configuration</a>
                <a href="https://cuongvndev.github.io/tags/spring-cloud-netflix/">Spring Cloud Netflix</a>
                
            </div>


          
          <nav class="post-nav">
            
              <a class="prev" href="/post/microservice-authentication-jwt-token-and-spring-cloud-configuaration-part-3/">
                
                <i class="iconfont">
                  <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

                </i>
                <span class="prev-text nav-default">Hướng dẫn sử dụng Microservice, Eureka và Zuul Gateway - Phần 3</span>
                <span class="prev-text nav-mobile">Prev</span>
              </a>
            
              <a class="next" href="/post/microservice-with-spring-boot-eureka-and-zuul-gateway/">
                <span class="next-text nav-default">Hướng dẫn sử dụng Microservice, Eureka và Zuul Gateway - Phần 1</span>
                <span class="prev-text nav-mobile">Next</span>
                
                <i class="iconfont">
                  <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

                </i>
              </a>
          </nav>
        </footer>
      </article>

      
      


      
      

  

  
  

  
  

  

  <div class="disqus-comment">
  <div id="disqus_thread"></div>
  <script type="text/javascript">
    let mountNode = document.querySelector("#disqus_thread");
  let options = {
    rootMargin: "0px",
    threshold: 0,
  };

  let observer = new IntersectionObserver((entries, observer) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        console.log("Initialize Disqus!");

        

        var disqus_config = function () {
          this.page.url = "https://cuongvndev.github.io/post/microservice-authentication-jwt-token-and-spring-cloud-configuaration/";
        };
        var disqus_shortname = 'cuongvndev';

        var d = document,
          s = d.createElement("script");
        s.src = "https://"+disqus_shortname+".disqus.com/embed.js";

        s.setAttribute("data-timestamp", +new Date());
        (d.head || d.body).appendChild(s);

        

        
        observer.unobserve(mountNode);
        return;
      }
    });
  }, options);

  observer.observe(mountNode);
  </script>
  <noscript
    >Please enable JavaScript to view the
    <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
  </noscript>
  
</div>

    

  

  


    </div>

    
    <nav class="toc" id="toc">
    <div class="toc-title">Nội dung bài viết</div>
    <div class="toc-content custom-scrollbar">
      <nav id="TableOfContents">
  <ul>
    <li><a href="#1-jwt-json-based-token">1. JWT (Json Based Token)</a></li>
    <li><a href="#2-zuul-gateway">2. Zuul gateway</a></li>
    <li><a href="#3-common-service">3. Common service</a></li>
    <li><a href="#4-auth-service">4. Auth Service</a></li>
    <li><a href="#5-testing">5. Testing</a></li>
  </ul>
</nav>
    </div>
  </nav>


  </div>

      </main>

      <footer id="footer" class="footer">
        <div class="icon-links">
  
  
    <a href="https://cuongvndev.github.io" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>


<a href="https://cuongvndev.github.io/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
  
</div>

<div class="copyright">
  <span class="copyright-year">
    &copy;
    2023
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        Cuong Vu
        
      </span></span>

  
  

  
</div>

      </footer>

      <div class="button__back-to-top">
        <a href="#back-to-top">
          <i class="iconfont">
            
            <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

          </i>
        </a>
      </div>
    </div>
    
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.5258798749a15d6e3d4b1463628192936296559867ef2e751a83806ddd095b59.js" integrity="sha256-Ulh5h0mhXW49SxRjYoGSk2KWVZhn7y51GoOAbd0JW1k=" crossorigin="anonymous"></script>












  
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  

















  </body>
</html>
