<!DOCTYPE html>
<html lang="vi"><head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hướng dẫn sử dụng Microservice, Eureka và Zuul Gateway - Phần 1</title>
    <meta charset="utf-8">
    <meta name="description" content="Ladder@Bài viết này cung cấp một hướng dẫn chi tiết về việc triển khai và sử dụng kiến trúc Microservice kết hợp với các công cụ Eureka và Zuul Gateway. Đây là những bước cơ bản để xây dựng một hệ thống phân tán linh hoạt và có khả năng mở rộng.">
    <meta name="author" content="Cương Vũ">
    <link rel="canonical" href="https://cuongvndev.github.io/blog/microservice-with-spring-boot-eureka-and-zuul-gateway/">
        <meta name="google-site-verification" content="cNWPyAe0dni0K3m6i73pyaWDStJa7rPPmpZPshKnlos">

    <link rel="alternate" type="application/rss+xml" href="https://cuongvndev.github.io/index.xml" title="Cương Vũ Blog">

    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-xxx"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-xxx', { 'anonymize_ip': false });
}
</script>



    <meta property="og:title" content="Hướng dẫn sử dụng Microservice, Eureka và Zuul Gateway - Phần 1" />
<meta property="og:description" content="Bài viết này cung cấp một hướng dẫn chi tiết về việc triển khai và sử dụng kiến trúc Microservice kết hợp với các công cụ Eureka và Zuul Gateway. Đây là những bước cơ bản để xây dựng một hệ thống phân tán linh hoạt và có khả năng mở rộng." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cuongvndev.github.io/blog/microservice-with-spring-boot-eureka-and-zuul-gateway/" /><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2023-08-10T11:18:56+07:00" />
<meta property="article:modified_time" content="2023-08-10T11:18:56+07:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Hướng dẫn sử dụng Microservice, Eureka và Zuul Gateway - Phần 1"/>
<meta name="twitter:description" content="Bài viết này cung cấp một hướng dẫn chi tiết về việc triển khai và sử dụng kiến trúc Microservice kết hợp với các công cụ Eureka và Zuul Gateway. Đây là những bước cơ bản để xây dựng một hệ thống phân tán linh hoạt và có khả năng mở rộng."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Blogs",
      "item": "https://cuongvndev.github.io/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Hướng dẫn sử dụng Microservice, Eureka và Zuul Gateway - Phần 1",
      "item": "https://cuongvndev.github.io/blog/microservice-with-spring-boot-eureka-and-zuul-gateway/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Hướng dẫn sử dụng Microservice, Eureka và Zuul Gateway - Phần 1",
  "name": "Hướng dẫn sử dụng Microservice, Eureka và Zuul Gateway - Phần 1",
  "description": "Bài viết này cung cấp một hướng dẫn chi tiết về việc triển khai và sử dụng kiến trúc Microservice kết hợp với các công cụ Eureka và Zuul Gateway. Đây là những bước cơ bản để xây dựng một hệ thống phân tán linh hoạt và có khả năng mở rộng.\n",
  "keywords": [
    
  ],
  "articleBody": "Bài viết này cung cấp một hướng dẫn chi tiết về việc triển khai và sử dụng kiến trúc Microservice kết hợp với các công cụ Eureka và Zuul Gateway. Đây là những bước cơ bản để xây dựng một hệ thống phân tán linh hoạt và có khả năng mở rộng.\n1. Giới thệu Microservices là một mô hình kiến trúc phần mềm đột phá, cho phép các ứng dụng được chia thành các phần nhỏ hơn và độc lập, được gọi là “microservices”. Mỗi microservice có thể phát triển, triển khai và quản lý riêng biệt, giúp tối ưu hóa khả năng mở rộng và duy trì.\nBây giờ tôi sẽ triển khai một hệ thống đơn giản như sau: 2. Eureka server Là máy chủ dùng để quản lý, đặt tên cho các service hay còn gọi là service registry, mục đích của nó là thay vì phải nhớ 64.233.181.99 thì bạn có thể vào trực tiếp google bằng địa chỉ google.com và khi mà các service thay đổi địa chỉ thì Eureka sẽ tự động cập nhật mà bạn không cần phải thay đổi code.\nMỗi service sẽ được đăng ký với Eureka và sẽ ping cho Eureka để đảm bảo chúng vẫn còn hoạt động, Nếu Eureka không nhận được thông báo nào từ service thì service đó sẽ tự động bị xoá.\nOk bây giờ hãy tạo mới project spring boot dùng Maven để quản lý dependencies và khai báo file pom.xml như sau:\norg.springframework.boot spring-boot-starter-web org.springframework.cloud spring-cloud-starter-netflix-eureka-server org.springframework.boot spring-boot-devtools runtime org.springframework.boot spring-boot-starter-test test Tiếp theo trong file application.yml cần config như sau:\nserver: port: 8761 spring: application: name: eureka-server eureka: client: register-with-eureka: false fetch-registry: true Cuối cùng trong class Application, chúng ta sử dụng @EnableEurekaServer để khai báo đây là một Eureka Server:\n@SpringBootApplication @EnableEurekaServer public class EurekaServerApplication { public static void main(String[] args) { SpringApplication.run(EurekaServerApplication.class, args); } } 3. Zuul Gateway Zuul là thành phần của hệ thống microservices được phát triển bởi Netflix. Nó hoạt động như một dịch vụ cổng (gateway) trong mô hình kiến trúc ứng dụng microservices, giúp quản lý và điều phối yêu cầu từ clients tới các dịch vụ microservices tương ứng.\nZuul Gateway có các chức năng chính sau:\nRouting (Định tuyến): client sẽ không thể gửi request đến từng serive được, chưa kể việc các service còn giao tiếp qua lại với nhau, thay vào đó client sẽ gửi request trực tiếp tới 1 địa chỉ duy nhất của gateway, lúc này gateway có nhiệm vụ tiếp nhận và phân phối đến các service tương ứng. Load Balancing (Cân bằng tải): phân phối request đến nhiều instance của 1 service. Authentication và Security (xác thực và bảo mật). Tiến hành cài đặt Zuul Gateway bằng cách tạo mới project Spring boot sử dụng các dependency sau:\norg.springframework.boot spring-boot-starter-web org.springframework.cloud spring-cloud-starter-netflix-zuul org.springframework.cloud spring-cloud-starter-netflix-eureka-client Sử dụng anotation @EnableZuulProxy và @EnableEurekaClient để khai báo đây là Zuul và Eureka Client:\n@SpringBootApplication @EnableZuulProxy @EnableEurekaClient public class ZuulServerApplication { public static void main(String[] args) { SpringApplication.run(ZuulServerApplication.class, args); } } Và đừng quên config nữa nhé:\nserver: port: 8080 zuul: routes: user-service: path: /user/** service-id: user-service product-service: path: /product/** service-id: product-service spring: application: name: zuul-server eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ register-with-eureka: true fetch-registry: true instance: prefer-ip-address: true Định nghĩa routers ở trong zuul nói cho zuul biết rằng khi user truy cập với đường dẫn /user/** thì chuyển hướng tới user-service , còn service-id như ở trên mình đã nói Eureka sẽ đăng ký user service với cái tên là user-service thay vì sử dụng http://localhost:8083\n4. Bussiness service Các Eureka client service là một service độc lập trong kiến trúc microservice. Mỗi client service chỉ thực hiện duy nhất một nghiệp vụ nào đó trong hệ thống như thanh toán, tài khoản, thông báo, xác thực, cấu hình,…\nUser Service\nOk, cũng như Eureka Server, chúng ta sẽ tạo một project Spring Boot mới nhưng sử dụng Eureka Client trong file pom.xml:\norg.springframework.boot spring-boot-starter-web org.springframework.cloud spring-cloud-starter-netflix-eureka-client org.springframework.boot spring-boot-starter-test test Trong file application.yml chúng ta sẽ ghi nhận lại địa chỉ của Eureka Server:\nserver: port: 8083 spring: application: name: user-service eureka: client: service-url: defaultZone: http://localhost:8761/eureka/ Sau đó để chỉ cho Spring Boot biết đây là một Eureka client, chúng ta dùng annotation @EnableEurekaClient trong class main:\n@SpringBootApplication @EnableEurekaClient public class UserServiceApplication { public static void main(String[] args) { SpringApplication.run(UserServiceApplication.class, args); } } Tiến hành tạo controller để test:\nUserController.java import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class UserController { @GetMapping(\"/user\") public String getUser() { // Hardcode user info String userInfo = \"Username: john_doe\\nFull Name: John Doe\\nEmail: john@example.com\"; return userInfo; } } ở đây mình sẽ hardcode cho nhanh gọn lẹ\n5. Testing Ok, như vậy là chúng ta đã tạo xong bộ khung cho hệ thống microservice Tiến hành run các service theo thứ tự: Eureka, Zuul và User Để kiểm tra các service của chúng ta vào localhost://8761 đây là cổng của Eureka Server, và bạn có thể thấy các service đang chạy như hình: Tiến hành run api để get user info khi call api http://localhost:8083/user-info đang thực hiện call trực tiếp đến user service port 8083\nkhi call api http://localhost:8080/user/user-info đang thực hiện call thông qua zuul gateway port 8080 zuul gateway sẽ dựa vào path: /user/** để điều hướng tới user service\nKết thúc phần đầu tiên ở đây, ở phần tiếp theo chúng ta sẽ tìm hiều về cách để xác thực user trong hệ thống microservice và sử dụng Spring Cloud Configuration để config các biến được sử dụng chung cho nhiều service nhé!\n",
  "wordCount" : "954",
  "inLanguage": "vi",
  "datePublished": "2023-08-10T11:18:56+07:00",
  "dateModified": "2023-08-10T11:18:56+07:00",
  "author":{
    "@type": "Person",
    "name": "Cương Vũ"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://cuongvndev.github.io/blog/microservice-with-spring-boot-eureka-and-zuul-gateway/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Cương Vũ Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://cuongvndev.github.io/favicon.ico"
    }
  }
}
</script>
    <link rel="icon" href="/images/avatar.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/avatar.png">

<link rel="manifest" href="/images/avatar.png">

    <link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css" />

    
    
    
    <link rel="stylesheet" href="/css/main.min.ceb8c5fea2a3640fb422787e317dec5f3a3ef344b4d1d27376310d0ad2c746eb.css" integrity="sha256-zrjF/qKjZA&#43;0Inh&#43;MX3sXzo&#43;80S00dJzdjENCtLHRus=" crossorigin="anonymous" media="screen" />
    


    
    <link rel="stylesheet" href="/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css" />

    
    <script src="/js/highlight.min.min.294725d6634a4b99d13d57b152b522eeb7e97cbcc1630f8527d04bfe539bb4a9.js"></script>
    <script>hljs.highlightAll();</script>

    <script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script>
    </head>
<body>
      <main class="wrapper"><nav class="navigation">
    <section class="container">
        <a class="navigation-brand" href="/">
            Cương Vũ Blog
        </a>
        <input type="checkbox" id="menu-toggle" />
        <label class="menu-button float-right" for="menu-toggle">
            <span></span><span></span><span></span>
        </label>
        
        <ul class="navigation-list" id="navigation-list">
            
            
            <li class="navigation-item navigation-menu">
                <a class="navigation-link" href="/blog">Blog</a>
            </li>
            
            

            <li class="navigation-item menu-separator">
                <span>|</span>
            </li>

            
            
            <li class="navigation-item navigation-social">
                <a class="navigation-link" href="https://github.com/cuongvndev"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a>
            </li>
            
            

            <li class="navigation-item navigation-dark">
                <button id="mode" type="button" aria-label="toggle user light or dark theme">
                    <span class="toggle-dark"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg></span>
                    <span class="toggle-light"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg></span>
                </button>
            </li>

            
            
        </ul>
        
    </section>
</nav>
<div id="content">
<article class="blog-single">
  <header class="blog-title">
    <h1>Hướng dẫn sử dụng Microservice, Eureka và Zuul Gateway - Phần 1</h1>
  </header>

  <p>
  <small>
    10 tháng 8, 2023&nbsp;· &nbsp;· </small>

  
<p>

  <div class="blog-toc">
    <nav id="TableOfContents"></nav>
  </div>

  <section class="blog-content"><p>Bài viết này cung cấp một hướng dẫn chi tiết về việc triển khai và sử dụng kiến trúc Microservice kết hợp với các công cụ Eureka và Zuul Gateway. Đây là những bước cơ bản để xây dựng một hệ thống phân tán linh hoạt và có khả năng mở rộng.</p>
<h1 id="1-giới-thệu">1. Giới thệu</h1>
<p><strong>Microservices</strong> là một mô hình kiến trúc phần mềm đột phá, cho phép các ứng dụng được chia thành các phần nhỏ hơn và độc lập, được gọi là &ldquo;microservices&rdquo;. Mỗi microservice có thể phát triển, triển khai và quản lý riêng biệt, giúp tối ưu hóa khả năng mở rộng và duy trì.</p>
<p>Bây giờ tôi sẽ triển khai một hệ thống đơn giản như sau:
<img src="/model.png" alt="Scenario 1: Across columns"></p>
<h1 id="2-eureka-server">2. Eureka server</h1>
<p>Là máy chủ dùng để quản lý, đặt tên cho các service hay còn gọi là <code>service registry</code>, mục đích của nó là thay vì phải nhớ 64.233.181.99 thì bạn có thể vào trực tiếp google bằng địa chỉ google.com và khi mà các service thay đổi địa chỉ thì Eureka sẽ tự động cập nhật mà bạn không cần phải thay đổi code.</p>
<p>Mỗi service sẽ được đăng ký với Eureka và sẽ ping cho Eureka để đảm bảo chúng vẫn còn hoạt động, Nếu Eureka không nhận được thông báo nào từ service thì service đó sẽ tự động bị xoá.</p>
<p>Ok bây giờ hãy tạo mới project spring boot dùng Maven để quản lý dependencies và khai báo file <code>pom.xml</code> như sau:</p>
<pre tabindex="0"><code>&lt;dependencies&gt;  
    &lt;dependency&gt;  
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;  
    &lt;/dependency&gt;  
    &lt;dependency&gt;  
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  
        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;  
    &lt;/dependency&gt;  
    &lt;dependency&gt;  
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  
        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;  
        &lt;scope&gt;runtime&lt;/scope&gt;  
    &lt;/dependency&gt;  
    &lt;dependency&gt;  
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;  
        &lt;scope&gt;test&lt;/scope&gt;  
    &lt;/dependency&gt;  
&lt;/dependencies&gt;
</code></pre><p>Tiếp theo trong file <code>application.yml</code> cần config như sau:</p>
<pre tabindex="0"><code>server:
  port: 8761
spring:
  application:
    name: eureka-server
eureka:
  client:
    register-with-eureka: false
    fetch-registry: true
</code></pre><p>Cuối cùng trong class Application, chúng ta sử dụng <code>@EnableEurekaServer</code> để khai báo đây là một Eureka Server:</p>
<pre tabindex="0"><code>@SpringBootApplication
@EnableEurekaServer
public class EurekaServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaServerApplication.class, args);
    }
}
</code></pre><h1 id="3-zuul-gateway">3. Zuul Gateway</h1>
<p>Zuul là thành phần của hệ thống microservices được phát triển bởi Netflix. Nó hoạt động như một dịch vụ cổng (gateway) trong mô hình kiến trúc ứng dụng microservices, giúp quản lý và điều phối yêu cầu từ clients tới các dịch vụ microservices tương ứng.</p>
<p>Zuul Gateway có các chức năng chính sau:</p>
<ul>
<li>Routing (Định tuyến): client sẽ không thể gửi request đến từng serive được, chưa kể việc các service còn giao tiếp qua lại với nhau, thay vào đó client sẽ gửi request trực tiếp tới 1 địa chỉ duy nhất của gateway, lúc này gateway có nhiệm vụ tiếp nhận và phân phối đến các service tương ứng.</li>
<li>Load Balancing (Cân bằng tải): phân phối request đến nhiều instance của 1 service.</li>
<li>Authentication và Security (xác thực và bảo mật).</li>
</ul>
<p>Tiến hành cài đặt Zuul Gateway bằng cách tạo mới project Spring boot sử dụng các dependency sau:</p>
<pre tabindex="0"><code>        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre><p>Sử dụng anotation <code>@EnableZuulProxy</code> và <code>@EnableEurekaClient</code> để khai báo đây là Zuul và Eureka Client:</p>
<pre tabindex="0"><code>@SpringBootApplication
@EnableZuulProxy
@EnableEurekaClient
public class ZuulServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(ZuulServerApplication.class, args);
    }
}
</code></pre><p>Và đừng quên config nữa nhé:</p>
<pre tabindex="0"><code>server:
  port: 8080

zuul:
  routes:
    user-service:
      path: /user/**
      service-id: user-service
    product-service:
      path: /product/**
      service-id: product-service

spring:
  application:
    name: zuul-server

eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/
    register-with-eureka: true
    fetch-registry: true
  instance:
    prefer-ip-address: true
</code></pre><blockquote>
<p>Định nghĩa routers ở trong zuul nói cho zuul biết rằng khi user truy cập với đường dẫn <code>/user/**</code> thì chuyển hướng tới user-service
, còn service-id như ở trên mình đã nói Eureka sẽ đăng ký user service với cái tên là user-service thay vì sử dụng <code>http://localhost:8083</code></p>
</blockquote>
<h1 id="4-bussiness-service">4. Bussiness service</h1>
<p>Các Eureka client service là một service độc lập trong kiến trúc microservice. Mỗi client service chỉ thực hiện duy nhất một nghiệp vụ nào đó trong hệ thống như thanh toán, tài khoản, thông báo, xác thực, cấu hình,…</p>
<p><strong>User Service</strong></p>
<p>Ok, cũng như Eureka Server, chúng ta sẽ tạo một project Spring Boot mới nhưng sử dụng Eureka Client trong file <code>pom.xml</code>:</p>
<pre tabindex="0"><code>    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre><p>Trong file <code>application.yml</code> chúng ta sẽ ghi nhận lại địa chỉ của Eureka Server:</p>
<pre tabindex="0"><code>server:
  port: 8083
spring:
  application:
    name: user-service
eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
</code></pre><p>Sau đó để chỉ cho Spring Boot biết đây là một Eureka client, chúng ta dùng annotation <code>@EnableEurekaClient</code> trong class main:</p>
<pre tabindex="0"><code>@SpringBootApplication
@EnableEurekaClient
public class UserServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(UserServiceApplication.class, args);
    }
}
</code></pre><p>Tiến hành tạo controller để test:</p>
<ul>
<li><strong>UserController.java</strong></li>
</ul>
<pre tabindex="0"><code>import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class UserController {

    @GetMapping(&#34;/user&#34;)
    public String getUser() {
        // Hardcode user info
        String userInfo = &#34;Username: john_doe\nFull Name: John Doe\nEmail: john@example.com&#34;;

        return userInfo;
    }
}
</code></pre><blockquote>
<p>ở đây mình sẽ hardcode cho nhanh gọn lẹ</p>
</blockquote>
<h1 id="5-testing">5. Testing</h1>
<p>Ok, như vậy là chúng ta đã tạo xong bộ khung cho hệ thống microservice
Tiến hành run các service theo thứ tự: Eureka, Zuul và User
Để kiểm tra các service của chúng ta vào <code>localhost://8761</code> đây là cổng của Eureka Server, và bạn có thể thấy các service đang chạy như hình:
<img src="/service-eureka.png" alt="Scenario 1: Across columns"></p>
<p>Tiến hành run api để get user info
<img src="/api-user-info.png#center" alt="Scenario 2: Across columns"></p>
<blockquote>
<p>khi call api <code>http://localhost:8083/user-info</code> đang thực hiện call trực tiếp đến user service port 8083</p>
</blockquote>
<p><img src="/api-user-info2.png#center" alt="Scenario 2: Across columns"></p>
<blockquote>
<p>khi call api <code>http://localhost:8080/user/user-info</code> đang thực hiện call thông qua zuul gateway port 8080
zuul gateway sẽ dựa vào path: /user/** để điều hướng tới user service</p>
</blockquote>
<p>Kết thúc phần đầu tiên ở đây, ở phần tiếp theo chúng ta sẽ tìm hiều về cách để xác thực user trong hệ thống microservice và sử dụng Spring Cloud Configuration để config các biến được sử dụng chung cho nhiều service nhé!</p></section>

  
  

  


  
  
  
</article>


        </div><footer class="footer">
  <p>&copy; 2023 <a href="https://cuongvndev.github.io">Cương Vũ Blog</a>
    Powered by
    <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo️️</a>
    <a href="https://github.com/guangzhengli/hugo-theme-ladder" rel="noopener" target="_blank">Ladder</a>
️  </p>
</footer>

<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211C22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257M21.7387 7.71865C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257C17.1684 -1.24629 7.83127 0.632493 4.27577 5.04257C2.88063 6.77451 -0.0433281 11.1668 1.38159 16.6571C2.27481 20.0988 5.17269 22.2936 8.19743 22.7725M20.7188 5.04257C22.0697 6.9404 24.0299 11.3848 22.3541 15.4153M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814C11.1703 6.98257 11.0247 6.98456 10.9937 7.05061C10.5221 8.05496 9.07362 9.92941 8 10.945M11.0333 7.44444C10.9392 9.86549 11 15 12 17" stroke="currentColor" stroke-linecap="round"/>
    </svg>
</a>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
</script>

<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'Copy';

        function copyingDone() {
            copybutton.innerHTML = 'Copied';
            setTimeout(() => {
                copybutton.innerHTML = 'Copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });
        codeblock.parentNode.appendChild(copybutton);
    });
</script></main>
    </body><script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js" integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <script>
      const images = Array.from(document.querySelectorAll(".blog-content img"));
      images.forEach(img => {
          mediumZoom(img, {
              margin: 10,  
              scrollOffset: 40,  
              container: null,  
              template: null,  
              background: 'rgba(0, 0, 0, 0.5)'
          });
      });
  </script>

  
  <script src="/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js" integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin="anonymous" defer></script></html>
