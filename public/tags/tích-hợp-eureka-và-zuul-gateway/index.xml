<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tích hợp Eureka và Zuul Gateway on Cương Vũ Blog</title>
    <link>https://cuongvndev.github.io/tags/t%C3%ADch-h%E1%BB%A3p-eureka-v%C3%A0-zuul-gateway/</link>
    <description>Recent content in Tích hợp Eureka và Zuul Gateway on Cương Vũ Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>vi</language>
    <lastBuildDate>Fri, 11 Aug 2023 09:25:25 +0700</lastBuildDate><atom:link href="https://cuongvndev.github.io/tags/t%C3%ADch-h%E1%BB%A3p-eureka-v%C3%A0-zuul-gateway/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Hướng dẫn sử dụng Microservice, Eureka và Zuul Gateway - Phần 2</title>
      <link>https://cuongvndev.github.io/blog/microservice-authentication-jwt-token-and-spring-cloud-configuaration/</link>
      <pubDate>Fri, 11 Aug 2023 09:25:25 +0700</pubDate>
      
      <guid>https://cuongvndev.github.io/blog/microservice-authentication-jwt-token-and-spring-cloud-configuaration/</guid>
      <description>&lt;p&gt;Ở bài trước chúng ta đã dựng được một hệ thống microservice đơn giản với User service, Eureka server và Zuul gateway.
Trong bài viết này chúng ta sẽ cùng tìm hiểu về &lt;strong&gt;JWT&lt;/strong&gt; và cách để &lt;strong&gt;xác thực và bảo mật&lt;/strong&gt; trong hệ thống &lt;strong&gt;Microservice&lt;/strong&gt; bằng JWT.&lt;/p&gt;
&lt;p&gt;Chúng ta sẽ tạo 1 service mới là &lt;code&gt;auth service&lt;/code&gt; có nhiệm vụ xác minh danh tính và tạo jwt token khi user login
Còn việc xác thực token sẽ do Zuul gateway đảm nhận, khi có 1 request gửi đến thì Zuul gateway sẽ dựa vào token được cung cấp và xác thực quyền truy cập, xác thực thành công thì mới tiến hành điều hướng request tới các service bussiness khác.&lt;/p&gt;
&lt;h1 id=&#34;1-jwt-json-based-token&#34;&gt;1. JWT (Json Based Token)&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Token&lt;/strong&gt; là 1 chuỗi string được mã hoá được tạo ra từ hệ thống của chúng ta sau khi xác thực thành công. Và được đính kèm trong các request để cung cấp quyền truy cập vào ứng dụng.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JWT&lt;/strong&gt; là 1 chuẩn JSON để tạo token, được bao gồm bởi 3 phần&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Header: chứa thuật toán hash
&lt;code&gt;{type: “JWT”, hash: “HS256”}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Payload: chứa các thuộc tính user name, email,&amp;hellip; và các giá trị của nó
&lt;code&gt;{username: &amp;quot;Omar&amp;quot;, email: &amp;quot;omar@example.com&amp;quot;, admin: true }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Signature: là giá trị hash của &lt;code&gt;Header + “.” + Payload + Secret key&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2-zuul-gateway&#34;&gt;2. Zuul gateway&lt;/h1&gt;
&lt;p&gt;Ở trong gateway sẽ thực hiện 2 chức năng: một xác thực token và 2 là chặn tất cả request nếu xác thực không thành công.
Trong file &lt;code&gt;pom.xml&lt;/code&gt; chúng ta cần thêm spring security và JWT&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.jsonwebtoken&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jjwt&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Để sử dụng security thì chúng ta cần tạo 1 class extend từ &lt;code&gt;WebSecurityConfigurerAdapter&lt;/code&gt; và dùng anotation &lt;code&gt;@EnableWebSecurity&lt;/code&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package com.example.zuulserver.security;

import com.example.commonservice.security.JwtConfig;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

import javax.servlet.http.HttpServletResponse;
import javax.ws.rs.HttpMethod;

@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    
    @Autowired
    private JwtConfig jwtConfig;
    
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                .csrf().disable()
                // make sure we use stateless session; session won&amp;#39;t be used to store user&amp;#39;s state.
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .and()
                // handle an authorized attempts
                .exceptionHandling().authenticationEntryPoint((req, rsp, e) -&amp;gt; rsp.sendError(HttpServletResponse.SC_UNAUTHORIZED))
                .and()
                // Add a filter to validate the tokens with every request
                .addFilterAfter(new JwtTokenAuthenticationFilter(jwtConfig), UsernamePasswordAuthenticationFilter.class)
                // authorization requests config
                .authorizeRequests()
                // allow all who are accessing &amp;#34;auth&amp;#34; service
                .antMatchers(HttpMethod.POST, jwtConfig.getUri()).permitAll()
                // Any other request must be authenticated
                .anyRequest().authenticated();
    }
    
    @Bean
    public JwtConfig jwtConfig() {
        return new JwtConfig();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;Class JwtConfig sẽ được tạo sau ở trong phần common service&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Tiếp theo chúng ta sẽ viết class filter để xác thực token được đặt tên là &lt;code&gt;JwtTokenAuthenticationFilter&lt;/code&gt;, class này sẽ extend từ &lt;code&gt;OncePerRequestFilter&lt;/code&gt; filter này sẽ được kích hoạt mỗi khi request được gửi tới.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package com.example.zuulserver.security;

import com.example.commonservice.security.JwtConfig;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.filter.OncePerRequestFilter;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;
import java.util.stream.Collectors;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;

public class JwtTokenAuthenticationFilter extends OncePerRequestFilter {
    
    private final JwtConfig jwtConfig;
    
    public JwtTokenAuthenticationFilter(JwtConfig jwtConfig) {
        this.jwtConfig = jwtConfig;
    }
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        // 1. get the authentication header. Tokens are supposed to be passed in the authentication header
        String header = request.getHeader(jwtConfig.getHeader());
        
        // 2. validate the header and check the prefix
        if (header == null || !header.startsWith(jwtConfig.getPrefix())) {
            filterChain.doFilter(request, response); // if not valid go to the next filter
            return;
        }
        // If there is no token provided and hence the user won&amp;#39;t be authenticated.
        // It&amp;#39;s Ok. Maybe the user accessing a public path or asking for a token.
        // All secured paths that needs a token are already defined and secured in config class.
        // And If user tried to access without access token, then he won&amp;#39;t be authenticated and an exception will be thrown.
        // 3. Get the token
        String token = header.replace(jwtConfig.getPrefix(), &amp;#34;&amp;#34;);
        try {  // exceptions might be thrown in creating the claims if for example the token is expired
            // 4. Validate the token
            Claims claims = Jwts.parser().setSigningKey(jwtConfig.getSecret().getBytes()).parseClaimsJws(token).getBody();
            
            String userName = claims.getSubject();
            if (userName != null) {
                List&amp;lt;String&amp;gt; authorities = (List&amp;lt;String&amp;gt;) claims.get(&amp;#34;authorities&amp;#34;);
                
                // 5. Create auth object
                // UsernamePasswordAuthenticationToken: A built-in object, used by spring to represent the current authenticated / being authenticated user. // It needs a list of authorities, which has type of GrantedAuthority interface, where SimpleGrantedAuthority is an implementation of that interface
                UsernamePasswordAuthenticationToken auth = new UsernamePasswordAuthenticationToken(userName, null, authorities.stream().map(SimpleGrantedAuthority::new).collect(Collectors.toList()));
                // 6. Authenticate the user
                // Now, user is authenticated
                SecurityContextHolder.getContext().setAuthentication(auth);
            }
        } catch (Exception e) {
            // In case of failure. Make sure it&amp;#39;s clear; so guarantee user won&amp;#39;t be authenticated
            e.printStackTrace();
            SecurityContextHolder.clearContext();
        }
        // go to the next filter in the filter chain
        filterChain.doFilter(request, response);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;4-common-service&#34;&gt;4. Common service&lt;/h1&gt;
&lt;p&gt;Service này sẽ chứa những config được sử dụng chung cho nhiều service khác
Chúng ta sẽ tạo class JwtConfig để chứa các config JWT và class này sẽ được sử dụng trong Auth service và Zuul gateway&lt;/p&gt;
&lt;p&gt;Cũng tương tự như việc tạo các service khác hãy tạo mới project Spring boot và config file &lt;code&gt;pom.xml&lt;/code&gt; như sau:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Tạo class JwtConfig như sau:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package com.example.commonservice.security;

import org.springframework.beans.factory.annotation.Value;

public class JwtConfig {
    
    @Value(&amp;#34;${security.jwt.uri:/auth/**}&amp;#34;)
    private String uri;
    
    @Value(&amp;#34;${security.jwt.header:Authorization}&amp;#34;)
    private String header;
    
    @Value(&amp;#34;${security.jwt.prefix:Bearer }&amp;#34;)
    private String prefix;
    
    @Value(&amp;#34;${security.jwt.expiration:#{24*60*60}}&amp;#34;)
    private int expiration;
    
    @Value(&amp;#34;${security.jwt.secret:JwtSecretKey}&amp;#34;)
    private String secret;
    
    public String getUri() {
        return uri;
    }
    
    public void setUri(String uri) {
        this.uri = uri;
    }
    
    public String getHeader() {
        return header;
    }
    
    public void setHeader(String header) {
        this.header = header;
    }
    
    public String getPrefix() {
        return prefix;
    }
    
    public void setPrefix(String prefix) {
        this.prefix = prefix;
    }
    
    public int getExpiration() {
        return expiration;
    }
    
    public void setExpiration(int expiration) {
        this.expiration = expiration;
    }
    
    public String getSecret() {
        return secret;
    }
    
    public void setSecret(String secret) {
        this.secret = secret;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Tiếp theo ở các service khác, chẳng hạn như ở Zuul gateway chúng ta cần khai báo dependency common service trong file &lt;code&gt;pom.xml&lt;/code&gt;:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;!-- common dependency--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.example&amp;lt;/groupId&amp;gt;
    artifactId&amp;gt;common-service&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;Thêm dependency common-service vào trong các service muốn sử dụng JwtConfig
Ở đây tạm thời chỉ có 1 class JwtConfig là sẽ được dùng chung, tương lai sẽ có nhiều hơn nên mình tách ra thành common luôn để sử dụng sau này&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Như vậy là đã xong phần security trong &lt;strong&gt;Zuull gateway&lt;/strong&gt;, tiếp theo đây sẽ tạo mới &lt;strong&gt;Auth service&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;5-auth-service&#34;&gt;5. Auth Service&lt;/h1&gt;
&lt;p&gt;Trong auth service, chúng ta sẽ làm hai việc: một là xác thực định danh mà người dùng cung cấp và hai là gen ra một token trong trường hợp xác thực hợp lệ hoặc trả về một exception nếu nó không hợp lệ.
Trong file &lt;code&gt;pom.xml&lt;/code&gt; chúng ta cần các dependencies sau: Web, Eureka Client, Spring Security và JWT.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;io.jsonwebtoken&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;jjwt&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;0.9.0&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!--common dependency--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.example&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;common-service&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;File &lt;code&gt;application.yml&lt;/code&gt; khai báo như các service khác:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;server:
  port: 8082

eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka

spring:
  application:
    name: auth-service
  cloud:
    config:
      uri: http://localhost:8888
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Ở trong class application cũng cần khai báo đây là Eureka client và đánh anotation &lt;code&gt;@EnableWebSecurity&lt;/code&gt; cho nó:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package com.example.authservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;

@SpringBootApplication
@EnableEurekaClient
public class AuthServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(AuthServiceApplication.class, args);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Giống như cấu hình cổng Gateway, chúng ta cần tạo một lớp extends từ &lt;code&gt;WebSecurityConfigurerAdapter&lt;/code&gt;:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package com.example.authservice.security;

import com.example.commonservice.security.JwtConfig;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

import javax.servlet.http.HttpServletResponse;
import javax.ws.rs.HttpMethod;

@EnableWebSecurity
public class SecurityCredentialsConfig  extends WebSecurityConfigurerAdapter {
    
    @Autowired
    private UserDetailsService userDetailsService;
    
    @Autowired
    private JwtConfig jwtConfig;
    
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                .csrf().disable()
                // make sure we use stateless session; session won&amp;#39;t be used to store user&amp;#39;s state.
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .and()
                // handle an authorized attempts
                .exceptionHandling().authenticationEntryPoint((req, rsp, e) -&amp;gt; rsp.sendError(HttpServletResponse.SC_UNAUTHORIZED))
                .and()
                // Add a filter to validate user credentials and add token in the response header
                // What&amp;#39;s the authenticationManager()?
                // An object provided by WebSecurityConfigurerAdapter, used to authenticate the user passing user&amp;#39;s credentials
                // The filter needs this auth manager to authenticate the user.
                .addFilter(new JwtUsernameAndPasswordAuthenticationFilter(authenticationManager(), jwtConfig))
                .authorizeRequests()
                // allow all POST requests
                .antMatchers(HttpMethod.POST, jwtConfig.getUri()).permitAll()
                .antMatchers(HttpMethod.GET, &amp;#34;/auth/test&amp;#34;).permitAll()
                // any other requests must be authenticated
                .anyRequest().authenticated();
    }
    
    // Spring has UserDetailsService interface, which can be overriden to provide our implementation for fetching user from database (or any other source).
    // The UserDetailsService object is used by the auth manager to load the user from database. // In addition, we need to define the password encoder also. So, auth manager can compare and verify passwords.  @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());
    }
    
    @Bean
    public BCryptPasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    @Bean
    public JwtConfig jwtConfig(){
        return new JwtConfig();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Trong đoạn code trên, chúng ta sử dụng interface &lt;code&gt;UserDetailsService&lt;/code&gt; nên chúng ta cần implement nó:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package com.example.authservice.security;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.AuthorityUtils;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;

import java.util.Arrays;
import java.util.List;

@Service
public class UserDetailsServiceImpl implements UserDetailsService {
    @Autowired
    private BCryptPasswordEncoder encoder;
    
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        
        // TODO get user by username in db currently we hardcode user for test
        // hard coding the users. All passwords must be encoded.
        final List&amp;lt;AppUser&amp;gt; users = Arrays.asList(
                new AppUser(1, &amp;#34;user&amp;#34;, encoder.encode(&amp;#34;12345&amp;#34;), &amp;#34;USER&amp;#34;),
                new AppUser(2, &amp;#34;admin&amp;#34;, encoder.encode(&amp;#34;12345&amp;#34;), &amp;#34;ADMIN&amp;#34;)
        );
        
        
        for(AppUser appUser: users) {
            if(appUser.getUsername().equals(username)) {
                
                // Remember that Spring needs roles to be in this format: &amp;#34;ROLE_&amp;#34; + userRole (i.e. &amp;#34;ROLE_ADMIN&amp;#34;)
                // So, we need to set it to that format, so we can verify and compare roles (i.e. hasRole(&amp;#34;ADMIN&amp;#34;)).
                List&amp;lt;GrantedAuthority&amp;gt; grantedAuthorities = AuthorityUtils
                         .commaSeparatedStringToAuthorityList(&amp;#34;ROLE_&amp;#34; + appUser.getRole());
                
                // The &amp;#34;User&amp;#34; class is provided by Spring and represents a model class for user to be returned by UserDetailsService
                // And used by auth manager to verify and check user authentication.
                return new User(appUser.getUsername(), appUser.getPassword(), grantedAuthorities);
            }
        }
        
        // If user not found. Throw this exception.
        throw new UsernameNotFoundException(&amp;#34;Username: &amp;#34; + username + &amp;#34; not found&amp;#34;);
    }
    
    // A (temporary) class represent the user saved in the database.
    private static class AppUser {
        private Integer id;
        private String username, password;
        private String role;
        
        public AppUser(Integer id, String username, String password, String role) {
            this.id = id;
            this.username = username;
            this.password = password;
            this.role = role;
        }
        
        public Integer getId() {
            return id;
        }
        
        public void setId(Integer id) {
            this.id = id;
        }
        
        public String getUsername() {
            return username;
        }
        
        public void setUsername(String username) {
            this.username = username;
        }
        
        public String getPassword() {
            return password;
        }
        
        public void setPassword(String password) {
            this.password = password;
        }
        
        public String getRole() {
            return role;
        }
        
        public void setRole(String role) {
            this.role = role;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Bước tiếp theo cũng là bước cuối cùng, chúng ta cần một filter. Ở đây chúng ta sử dụng &lt;code&gt;JwtUsernameAndPasswordAuthenticationFilter&lt;/code&gt; để xác thực định danh người dùng và tạo token. Các thông tin về username hay password phải được gửi dưới dạng POST request.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package com.example.authservice.security;

import com.example.commonservice.security.JwtConfig;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.web.util.matcher.AntPathRequestMatcher;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Collections;
import java.util.Date;
import java.util.stream.Collectors;

public class JwtUsernameAndPasswordAuthenticationFilter extends UsernamePasswordAuthenticationFilter {
    // We use auth manager to validate the user credentials
    private AuthenticationManager authManager;
    
    private final JwtConfig jwtConfig;
    
    public JwtUsernameAndPasswordAuthenticationFilter(AuthenticationManager authManager, JwtConfig jwtConfig) {
        this.authManager = authManager;
        this.jwtConfig = jwtConfig;
        
        // By default, UsernamePasswordAuthenticationFilter listens to &amp;#34;/login&amp;#34; path.
        // In our case, we use &amp;#34;/auth&amp;#34;. So, we need to override the defaults.
        this.setRequiresAuthenticationRequestMatcher(new AntPathRequestMatcher(jwtConfig.getUri(), &amp;#34;POST&amp;#34;));
    }
    
    @Override
    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response)
            throws AuthenticationException {
        
        try {
            
            // 1. Get credentials from request
            UserCredentials creds = new ObjectMapper().readValue(request.getInputStream(), UserCredentials.class);
            
            // 2. Create auth object (contains credentials) which will be used by auth manager
            UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(
                    creds.getUsername(), creds.getPassword(), Collections.emptyList());
            
            // 3. Authentication manager authenticate the user, and use UserDetialsServiceImpl::loadUserByUsername() method to load the user.
            return authManager.authenticate(authToken);
            
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
    
    // Upon successful authentication, generate a token.
    // The &amp;#39;auth&amp;#39; passed to successfulAuthentication() is the current authenticated user.  @Override
    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain,
                                            Authentication auth) throws IOException, ServletException {
        
        Long now = System.currentTimeMillis();
        String token = Jwts.builder()
                .setSubject(auth.getName())
                // Convert to list of strings.
                // This is important because it affects the way we get them back in the Gateway.
                .claim(&amp;#34;authorities&amp;#34;, auth.getAuthorities().stream()
                        .map(GrantedAuthority::getAuthority).collect(Collectors.toList()))
                .setIssuedAt(new Date(now))
                .setExpiration(new Date(now + jwtConfig.getExpiration() * 1000))  // in milliseconds
                .signWith(SignatureAlgorithm.HS512, jwtConfig.getSecret().getBytes())
                .compact();
        
        // Add token to header
        response.addHeader(jwtConfig.getHeader(), jwtConfig.getPrefix() + token);
    }
    
    // A (temporary) class just to represent the user credentials
    private static class UserCredentials {
        private String username, password;
        
        public String getUsername() {
            return username;
        }
        
        public void setUsername(String username) {
            this.username = username;
        }
        
        public String getPassword() {
            return password;
        }
        
        public void setPassword(String password) {
            this.password = password;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;Trong Auth service cũng đã sử dụng đến JwtConfig việc này tránh trùng lặp code&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;6-testing&#34;&gt;6. Testing&lt;/h1&gt;
&lt;p&gt;Chạy lần lượt các service Eureka, Zuul, Auth và User.&lt;/p&gt;
&lt;p&gt;Đầu tiên chúng ta thử truy cập vào user service thông qua đường dẫn &lt;code&gt;localhost:8762/user/user-info&lt;/code&gt; mà không có token. Chúng ta sẽ nhận về một lỗi 401 như sau:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;{
    &amp;#34;timestamp&amp;#34;: &amp;#34;2023-08-11T09:26:08.131+0000&amp;#34;,
    &amp;#34;status&amp;#34;: 401,
    &amp;#34;error&amp;#34;: &amp;#34;Unauthorized&amp;#34;,
    &amp;#34;message&amp;#34;: &amp;#34;No message available&amp;#34;,
    &amp;#34;path&amp;#34;: &amp;#34;/user/user-info&amp;#34;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Để nhận &lt;strong&gt;token&lt;/strong&gt;, chúng ta call api authentication &lt;code&gt;localhost:8762/auth&lt;/code&gt;
&lt;img src=&#34;https://cuongvndev.github.io/blog/microservice/authen.png&#34; alt=&#34;Scenario 1: Across columns&#34;&gt;&lt;/p&gt;
&lt;p&gt;Bây giờ gọi lại &lt;strong&gt;user service&lt;/strong&gt; kèm theo một &lt;strong&gt;token&lt;/strong&gt; trong header:
&lt;img src=&#34;https://cuongvndev.github.io/blog/microservice/user-info-auth.png&#34; alt=&#34;Scenario 1: Across columns&#34;&gt;&lt;/p&gt;
&lt;p&gt;Ngoài ta thì bạn có thể thử chạy nhiều instance của user service để test xem các request được phân tán như thế nào. Trong phần tiếp theo, chúng ta sẽ tìm hiểu các xử lý lỗi và theo dõi trong mô hình microservice.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Hướng dẫn sử dụng Microservice, Eureka và Zuul Gateway - Phần 1</title>
      <link>https://cuongvndev.github.io/blog/microservice-with-spring-boot-eureka-and-zuul-gateway/</link>
      <pubDate>Thu, 10 Aug 2023 11:18:56 +0700</pubDate>
      
      <guid>https://cuongvndev.github.io/blog/microservice-with-spring-boot-eureka-and-zuul-gateway/</guid>
      <description>&lt;p&gt;Bài viết này cung cấp một hướng dẫn chi tiết về việc triển khai và sử dụng kiến trúc &lt;strong&gt;Microservice&lt;/strong&gt; kết hợp với các công cụ &lt;strong&gt;Eureka&lt;/strong&gt; và Zuul &lt;strong&gt;Gateway&lt;/strong&gt;. Đây là những bước cơ bản để xây dựng một hệ thống phân tán linh hoạt và có khả năng mở rộng.&lt;/p&gt;
&lt;h1 id=&#34;1-giới-thệu&#34;&gt;1. Giới thệu&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Microservices&lt;/strong&gt; là một mô hình kiến trúc phần mềm đột phá, cho phép các ứng dụng được chia thành các phần nhỏ hơn và độc lập, được gọi là &amp;ldquo;microservices&amp;rdquo;. Mỗi microservice có thể phát triển, triển khai và quản lý riêng biệt, giúp tối ưu hóa khả năng mở rộng và duy trì.&lt;/p&gt;
&lt;p&gt;Bây giờ tôi sẽ triển khai một hệ thống đơn giản như sau:
&lt;img src=&#34;https://cuongvndev.github.io/blog/microservice/model.png&#34; alt=&#34;Scenario 1: Across columns&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;2-eureka-server&#34;&gt;2. Eureka server&lt;/h1&gt;
&lt;p&gt;Là máy chủ dùng để quản lý, đặt tên cho các service hay còn gọi là &lt;code&gt;service registry&lt;/code&gt;, mục đích của nó là thay vì phải nhớ 64.233.181.99 thì bạn có thể vào trực tiếp google bằng địa chỉ google.com và khi mà các service thay đổi địa chỉ thì Eureka sẽ tự động cập nhật mà bạn không cần phải thay đổi code.&lt;/p&gt;
&lt;p&gt;Mỗi service sẽ được đăng ký với Eureka và sẽ ping cho Eureka để đảm bảo chúng vẫn còn hoạt động, Nếu Eureka không nhận được thông báo nào từ service thì service đó sẽ tự động bị xoá.&lt;/p&gt;
&lt;p&gt;Ok bây giờ hãy tạo mới project spring boot dùng Maven để quản lý dependencies và khai báo file &lt;code&gt;pom.xml&lt;/code&gt; như sau:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;dependencies&amp;gt;  
    &amp;lt;dependency&amp;gt;  
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;  
        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;  
    &amp;lt;/dependency&amp;gt;  
    &amp;lt;dependency&amp;gt;  
        &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;  
        &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-server&amp;lt;/artifactId&amp;gt;  
    &amp;lt;/dependency&amp;gt;  
    &amp;lt;dependency&amp;gt;  
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;  
        &amp;lt;artifactId&amp;gt;spring-boot-devtools&amp;lt;/artifactId&amp;gt;  
        &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;  
    &amp;lt;/dependency&amp;gt;  
    &amp;lt;dependency&amp;gt;  
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;  
        &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;  
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;  
    &amp;lt;/dependency&amp;gt;  
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Tiếp theo trong file &lt;code&gt;application.yml&lt;/code&gt; cần config như sau:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;server:
  port: 8761
spring:
  application:
    name: eureka-server
eureka:
  client:
    register-with-eureka: false
    fetch-registry: true
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Cuối cùng trong class Application, chúng ta sử dụng &lt;code&gt;@EnableEurekaServer&lt;/code&gt; để khai báo đây là một Eureka Server:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@SpringBootApplication
@EnableEurekaServer
public class EurekaServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaServerApplication.class, args);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;3-zuul-gateway&#34;&gt;3. Zuul Gateway&lt;/h1&gt;
&lt;p&gt;Zuul là thành phần của hệ thống microservices được phát triển bởi Netflix. Nó hoạt động như một dịch vụ cổng (gateway) trong mô hình kiến trúc ứng dụng microservices, giúp quản lý và điều phối yêu cầu từ clients tới các dịch vụ microservices tương ứng.&lt;/p&gt;
&lt;p&gt;Zuul Gateway có các chức năng chính sau:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Routing (Định tuyến): client sẽ không thể gửi request đến từng serive được, chưa kể việc các service còn giao tiếp qua lại với nhau, thay vào đó client sẽ gửi request trực tiếp tới 1 địa chỉ duy nhất của gateway, lúc này gateway có nhiệm vụ tiếp nhận và phân phối đến các service tương ứng.&lt;/li&gt;
&lt;li&gt;Load Balancing (Cân bằng tải): phân phối request đến nhiều instance của 1 service.&lt;/li&gt;
&lt;li&gt;Authentication và Security (xác thực và bảo mật).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Tiến hành cài đặt Zuul Gateway bằng cách tạo mới project Spring boot sử dụng các dependency sau:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-zuul&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Sử dụng anotation &lt;code&gt;@EnableZuulProxy&lt;/code&gt; và &lt;code&gt;@EnableEurekaClient&lt;/code&gt; để khai báo đây là Zuul và Eureka Client:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@SpringBootApplication
@EnableZuulProxy
@EnableEurekaClient
public class ZuulServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(ZuulServerApplication.class, args);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Và đừng quên config nữa nhé:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;server:
  port: 8080

zuul:
  routes:
    user-service:
      path: /user/**
      service-id: user-service
    product-service:
      path: /product/**
      service-id: product-service

spring:
  application:
    name: zuul-server

eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/
    register-with-eureka: true
    fetch-registry: true
  instance:
    prefer-ip-address: true
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;Định nghĩa routers ở trong zuul nói cho zuul biết rằng khi user truy cập với đường dẫn &lt;code&gt;/user/**&lt;/code&gt; thì chuyển hướng tới user-service
, còn service-id như ở trên mình đã nói Eureka sẽ đăng ký user service với cái tên là user-service thay vì sử dụng &lt;code&gt;http://localhost:8083&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;4-bussiness-service&#34;&gt;4. Bussiness service&lt;/h1&gt;
&lt;p&gt;Các Eureka client service là một service độc lập trong kiến trúc microservice. Mỗi client service chỉ thực hiện duy nhất một nghiệp vụ nào đó trong hệ thống như thanh toán, tài khoản, thông báo, xác thực, cấu hình,…&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;User Service&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ok, cũng như Eureka Server, chúng ta sẽ tạo một project Spring Boot mới nhưng sử dụng Eureka Client trong file &lt;code&gt;pom.xml&lt;/code&gt;:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Trong file &lt;code&gt;application.yml&lt;/code&gt; chúng ta sẽ ghi nhận lại địa chỉ của Eureka Server:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;server:
  port: 8083
spring:
  application:
    name: user-service
eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Sau đó để chỉ cho Spring Boot biết đây là một Eureka client, chúng ta dùng annotation &lt;code&gt;@EnableEurekaClient&lt;/code&gt; trong class main:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@SpringBootApplication
@EnableEurekaClient
public class UserServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(UserServiceApplication.class, args);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Tiến hành tạo controller để test:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;UserController.java&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class UserController {

    @GetMapping(&amp;#34;/user-info&amp;#34;)
    public String getUser() {
        // Hardcode user info
        String userInfo = &amp;#34;Username: john_doe\nFull Name: John Doe\nEmail: john@example.com&amp;#34;;

        return userInfo;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;ở đây mình sẽ hardcode cho nhanh gọn lẹ&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;5-testing&#34;&gt;5. Testing&lt;/h1&gt;
&lt;p&gt;Ok, như vậy là chúng ta đã tạo xong bộ khung cho hệ thống microservice
Tiến hành run các service theo thứ tự: Eureka, Zuul và User
Để kiểm tra các service của chúng ta vào &lt;code&gt;localhost://8761&lt;/code&gt; đây là cổng của Eureka Server, và bạn có thể thấy các service đang chạy như hình:
&lt;img src=&#34;https://cuongvndev.github.io/blog/microservice/service-eureka.png&#34; alt=&#34;Scenario 1: Across columns&#34;&gt;&lt;/p&gt;
&lt;p&gt;Tiến hành run api để get user info
&lt;img src=&#34;https://cuongvndev.github.io/blog/microservice/api-user-info.png#center&#34; alt=&#34;Scenario 2: Across columns&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;khi call api &lt;code&gt;http://localhost:8083/user-info&lt;/code&gt; đang thực hiện call trực tiếp đến user service port 8083&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://cuongvndev.github.io/blog/microservice/api-user-info2.png#center&#34; alt=&#34;Scenario 2: Across columns&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;khi call api &lt;code&gt;http://localhost:8080/user/user-info&lt;/code&gt; đang thực hiện call thông qua zuul gateway port 8080
zuul gateway sẽ dựa vào path: /user/** để điều hướng tới user service&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Kết thúc phần đầu tiên ở đây, ở phần tiếp theo chúng ta sẽ tìm hiều về cách để xác thực user trong hệ thống microservice và tạo common sử dụng chung cho nhiều service nhé!&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>